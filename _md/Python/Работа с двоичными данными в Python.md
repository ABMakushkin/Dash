2024-11-18
#python 
[Working with Binary Data in Python - GeeksforGeeks](https://www.geeksforgeeks.org/working-with-binary-data-in-python/?ysclid=m3n17fm6v7472210416)


Ладно, давайте разберемся с этим! Основы довольно стандартны: 

1. В байте 8 бит.
2. Биты состоят либо из 0, либо из 1
3. Байт может быть интерпретирован по-разному, например, в двоичном, восьмеричном или шестнадцатеричном формате.

**Примечание:** Это не кодировки символов, они появятся позже. Это просто способ взглянуть на набор единиц и нулей и увидеть его тремя разными способами (или системами счисления).

**Примеры:** 

**Ввод:** 10011011
 
**Выход :**
1001 1011 ---- 9B (в шестнадцатеричном формате)
1001 1011 ---- 155 (в десятичной системе)
1001 1011 ---- 233 (в восьмеричной системе)

Это ясно показывает, что строка битов может быть интерпретирована по-разному разными способами. Мы часто используем шестнадцатеричное представление байта вместо двоичного, потому что его короче записывать, это всего лишь представление, а не интерпретация.

## Кодирование

Теперь, когда мы знаем, что такое байт и как он выглядит, давайте посмотрим, как он интерпретируется, в основном в _строках_ . Кодировки символов — это способ присваивать значения байтам или наборам байтов, которые представляют определенный символ в этой схеме. Некоторые кодировки — это ASCII (вероятно, самая старая), Latin и UTF-8 (наиболее широко используемая на сегодняшний день). В некотором смысле кодировки — это способ для компьютеров представлять, отправлять и интерпретировать читаемые человеком символы. Это означает, что предложение в одной кодировке может стать совершенно непонятным в другой кодировке.

## Python и байты

С точки зрения разработчика, самое большое изменение в Python 3 — это обработка строк. В Python 2 тип str использовался для двух разных видов значений — текста и байтов, тогда как в Python 3 это отдельные и несовместимые типы. Это означает, что до Python3 мы могли рассматривать набор байтов как строку и работать с ней, теперь это не так, теперь у нас есть отдельный тип данных, называемый _bytes._ Этот тип данных можно кратко описать как строку байтов, что по сути означает, что после инициализации типа данных bytes он становится неизменяемым. 

**Пример:**

- Питон3

|   |
|---|
|`bytestr` `=` `bytes(b``'abc'``)` <br><br>`# initializing a string with b`<br><br>`# makes it a binary string`<br><br>`print``(bytestr)`<br><br>`print``(bytestr[``0``])`<br><br>`bytestr[``0``]` `=` `97`|

**Выход:** 

б'абв'
97
Обратная трассировка (последний вызов последний):
  Файл "bytesExample.py", строка 4, в
    байтстр[0] = 97
TypeError: объект 'bytes' не поддерживает назначение элементов

Строка байтов — это то, что она называет, это просто строка байтов, например, «© ? ?» в «utf-8» — это 

b'\xC2\xA9\x20\xF0\x9D\x8C\x86\x20\xE2\x98\x83'

Это представляет собой еще одну проблему: нам необходимо знать кодировку двоичной строки, поскольку та же строка в другой кодировке (latin-1) выглядит по-другому.

© р в

**Пример:**

- Питон3

|   |
|---|
|`print``(b``'\xC2\xA9\x20\xF0\x9D\x8C\x86\x20\xE2\x98\x83'``.decode(``'utf-8'``))`<br><br>`print``(b``'\xC2\xA9\x20\xF0\x9D\x8C\x86\x20\xE2\x98\x83'``.decode(``'latin-1'``))`|

**Выход:**

![python-двоичный](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200617201900/python-binary.png)

Как видно выше, можно кодировать или декодировать строки и двоичные строки с помощью функции encode() или decode(). Нам нужна кодировка, потому что в некоторых кодировках невозможно декодировать строки. Эта проблема усугубляется, когда не используются нелатинские символы, такие как иврит, японский и китайский. Потому что в этих языках каждой букве назначается более одного байта. Но что мы используем, когда нам нужно изменить набор байтов? Мы используем _**bytearray**_ . 

**Пример:**

- Питон3

|   |
|---|
|`bytesArr` `=` `bytearray(b``'\x00\x0F'``)`<br><br>`# Bytearray allows modification`<br><br>`bytesArr[``0``]` `=` `255`<br><br>`bytesArr.append(``255``)`<br><br>`print``(bytesArr)`|

**Выход:**

байтовый массив(b'\xff\x0f\xff')

## Побитовые операции

В Python побитовые операторы используются для выполнения побитовых вычислений над целыми числами. Сначала целые числа преобразуются в двоичные, а затем над ними выполняются операции побитово, отсюда и название побитовые операторы. Ниже показаны стандартные побитовые операции. 

**Примечание:** для получения дополнительной информации обратитесь к [разделу Побитовые операторы Python.](https://www.geeksforgeeks.org/python-bitwise-operators/)

**Пример:**

- Питон3

|   |
|---|
|`# Code to demonstrate bitwise operations`<br><br>`# Some bytes to play with`<br><br>`byte1` `=` `int``(``'11110000'``,` `2``)`  `# 240`<br><br>`byte2` `=` `int``(``'00001111'``,` `2``)`  `# 15`<br><br>`byte3` `=` `int``(``'01010101'``,` `2``)`  `# 85`<br><br>`# Ones Complement (Flip the bits)`<br><br>`print``(~byte1)`<br><br>`# AND`<br><br>`print``(byte1 & byte2)`<br><br>`# OR`<br><br>`print``(byte1 \| byte2)`<br><br>`# XOR`<br><br>`print``(byte1 ^ byte3)`<br><br>`# Shifting right will lose the` <br><br>`# right-most bit`<br><br>`print``(byte2 >>` `3``)`<br><br>`# Shifting left will add a 0 bit` <br><br>`# on the right side`<br><br>`print``(byte2 <<` `1``)`<br><br>`# See if a single bit is set`<br><br>`bit_mask` `=` `int``(``'00000001'``,` `2``)`  `# Bit 1`<br><br>`# Is bit set in byte1?`<br><br>`print``(bit_mask & byte1)`<br><br>`# Is bit set in byte2?`<br><br>`print``(bit_mask & byte2)`|

**Выход:**

-241
0
255
165
1
30
0
1

## Некоторые другие приложения

Двоичные данные предоставляют несколько приложений, например, мы можем проверить, похожи ли два файла или нет, используя двоичные данные, мы также можем проверить, является ли файл jpeg или нет (или любым другим форматом изображения). Давайте рассмотрим примеры ниже для лучшего понимания.

**Пример 1:** Проверка, являются ли два файла одинаковыми или нет. Здесь используются два текстовых файла с данными следующим образом – 

**Файл 1:**

![](https://media.geeksforgeeks.org/wp-content/uploads/20200617201318/file1.png)

**Файл 2:**

![](https://media.geeksforgeeks.org/wp-content/uploads/20200617201350/file2.png)

- Питон3

|   |
|---|
|`with` `open``(``'GFG.txt'``,` `'rb'``) as file1,` `open``(``'log.txt'``,` `'rb'``) as file2:`<br><br>    `data1` `=` `file1.read()`<br><br>    `data2` `=` `file2.read()`<br><br>`if` `data1 !``=` `data2:`<br><br>    `print``(``"Files do not match."``)`<br><br>`else``:`<br><br>    `print``(``"Files match."``)`|

**Выход:**

Файлы не совпадают.

**Пример 2:** Проверка, является ли заданное изображение форматом jpeg или нет.

**Использованное изображение:**

![](https://media.geeksforgeeks.org/wp-content/uploads/20200617201508/food.jpeg)

- Питон3

|   |
|---|
|`import` `binascii`<br><br>`jpeg_signatures` `=` `[`<br><br>    `binascii.unhexlify(b``'FFD8FFD8'``),`<br><br>    `binascii.unhexlify(b``'FFD8FFE0'``),`<br><br>    `binascii.unhexlify(b``'FFD8FFE1'``)`<br><br>`]`<br><br>`with` `open``(``'food.jpeg'``,` `'rb'``) as` `file``:`<br><br>    `first_four_bytes` `=` `file``.read(``4``)`<br><br>    `if` `first_four_bytes` `in` `jpeg_signatures:`<br><br>        `print``(``"JPEG detected."``)`<br><br>    `else``:`<br><br>        `print``(``"File does not look like a JPEG."``)`|

**Выход:**

Обнаружен JPEG.

  

Х