2024-11-18
#python 
[Зачем __name__ == "__main__"? / Хабр](https://habr.com/ru/articles/702218/)

В этой небольшой статье мы рассмотрим один из самых популярных "новичковых" вопросов - зачем нам конструкция if __name__ == "__main__".

Эта статья ориентирована на начинающих разработчиков, я пытаюсь объяснить тему максимально понятно и доступно. Поэтому где-то лукавлю, где-то преувеличиваю, но это для лучшего понимания, не кидайтесь ананасами :)

---

Прежде чем изучить конструкцию if __ **name__** == __"**main__**", необходимо знать несколько вещей:

- Интерпретатор Python выполняет весь код, который сможет найти в файле.
    
- Когда Python запускает "исходный файл" в качестве основной программы, он присваивает переменной __name__ значение __main__
    

В языках программирования существует такое понятие, как **точка входа**. В некоторых языках программирования (C, C#, Go) конструкция _if_ **__name__** _== "_**__main__**_"_ не требуется, потому что в самом начале разработки задается точка входа, без нее компилятор выдаст ошибку. Python же относится к этому лояльно и позволяет пользователю не указывать точку входу (_Python в качестве точки входа считает первую строку)_, что может приводить к серьезным проблемам.

Также данная конструкция позволяет разделять файлы, чтобы они не пересекались при одновременной работе (при импорте модуля, либо при запуске самого модуля). 

Например, у нас есть две программы:

1. ([test.py](http://test.py/)) выводит значение переменной **__name__**, а затем строку "Hello world". 
    
2. (test_2.py) импортирует модуль test.
    

Если в качестве исходной (_откуда происходит запуск_) программы мы выберем [test.py](http://test.py/), то на выводе получаем следующее:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/8ba/643/5f2/8ba6435f2cb75412cb1dbd5b3fe40e13.png)

Так как в качестве исходной программы мы выбрали test.py, интерпретатор Python присвоил значение **переменной __name__**: **__main__**. Теперь попробуем запустить test_2.py.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/7de/21e/533/7de21e533bc98bff70f707b92148c7e8.png)

Как видим, вместо **__main__** мы получили test. Почему это произошло? Потому что мы запустили модуль test, в котором есть строка print(**__name__**), но так как мы запустили этот код из другой программы (test_2.py), интерпретатор не вывел **__main__**.

Проще говоря, если мы запускаем программу через «побочную» программу, то переменной **__name__** не будет задаваться значение **__main__**, что позволяет избежать лишнего срабатывания кода. Например:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/873/f77/bdc/873f77bdc05ea3593fa09159ad41e08d.png)

Мы запустили файл test.py и получили на вывод результат сложения двух чисел и их разность. Также в конце вывели строку, говорящую, что запуск выполнен с помощью test.py. Если же мы импортирует этот модуль в программу test_2.py, то получим на вывод следующее:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/ad3/3df/176/ad33df176c68dc87327b169f4fe88fe2.png)

А именно сообщение, что мы выполнили действия с помощью test.py, хотя в действительности это не так, ведь мы использовали test_2.py, а не test.py. Чтобы избежать подобного «лишнего» срабатывания фрагментов кода, необходимо в исходном файле (модуле) дописать конструкцию if **__name__** == “**__main__**”. Должно получиться вот так:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/467/8cf/59a/4678cf59ad17808587777590249865dd.png)

Теперь при импортировании модуля test в test_2.py будет выполняться проверка значения переменной **__name__**. Запускаем наш test_2.py и видим, что теперь срабатывания print(“успешно выполнено с помощью test.py”) не произошло. 

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/4df/461/f79/4df461f79339e4dfaf516994440761bd.png)

---

Благодарю за прочтение статьи, надеюсь вы подчерпнули из неё что-то новое.

Пишите в комменты какую тему разобрать в следующий раз, всем добра!

Мой GitHub: [https://github.com/Ryize](https://github.com/Ryize)