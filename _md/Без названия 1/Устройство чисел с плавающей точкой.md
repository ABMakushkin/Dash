2025-04-27
#python 


Тип `float` в Python может хранить значения в диапазоне -1.7*10308 до +1.7*10308. Такой гигантский диапазон значений объясняется тем, что тип `float` устроен совсем иначе по сравнению с целыми типами. Каждая переменная типа float содержит два числа: первое называется мантисса, а второе — степень.

Допустим, у нас есть число **123456789**, и мы сохранили его в переменную типа `float`. Тогда число будет преобразовано к виду **1**.23456789***10**8, и внутри типа `float` будут хранится два числа — 23456789 и 8. Красным выделена «значащая часть числа» (манти́сса), зелёным — степень.

Такой подход позволяет хранить как очень большие числа, так и очень маленькие. Но поскольку размер числа ограничен 8 байтами (64 бита) и часть бит используется под хранение степени (а также знака числа и знака степени), максимальная длина мантиссы ограничена 15 цифрами.

Это очень **упрощенное** описание устройства вещественных чисел, более полное можно загуглить.

## Потеря точности при работе с вещественными числами

При работе с вещественными числами всегда нужно иметь в виду, что вещественные числа — **неточные**. Всегда будут `ошибки округления, ошибки преобразования` из десятичной системы в двоичную и, наконец, самое частое — `потеря точности` при сложении/вычитании чисел слишком разных размерностей.

Последнее — самая неожиданная ситуация для новичков в программировании.

Если из числа **10^9** вычесть **1/10^9**, мы получим опять **10^9**.

Вычитание чисел слишком разных размерностей

```

1000000000.000000 000
   -     0.000000 001
1000000000.000000 000
                            
```

Объяснение
Второе число слишком маленькое, и его значащая часть игнорируется (выделено). Красным выделены 15 значащих цифр.

Что тут сказать, программирование — это не математика.

## Опасность сравнения вещественных чисел

Еще одна опасность подстерегает программистов при сравнении вещественных чисел. Поскольку при работе с этими числами могут накапливаться ошибки округления, то возможны ситуации, когда вещественные числа должны быть равны, но они не равны. И наоборот: числа должны быть не равны, но они равны.

Пример:
Команда
a = 1000000000.0 
b = 0.000000001 
c = a – b

Пояснение
В переменной a будет значение 1000000000.0
В переменной c будет значение 1000000000.0
(число в переменной b слишком маленькое)
В приведенном выше примере a и c не должны быть равны, но они равны.

Или возьмем другой пример:

Команда
a = 1.00000000000000001 
b = 1.00000000000000002
Пояснение
В переменной a будет значение 1.0
В переменной b будет значение 1.0

На практике вещественные числа сравнивают так:

Берется какое-то очень маленькое число (точность). Если разница чисел (по модулю) меньше, чем это маленькое число, то они считаются равными. Пример:

```python
a = 0.00000000012
b = 0.000000000011

if abs(a - b) < 0.00001:
    print("равны")
else:
    print("не равны")
```

