2025-04-22
#python 
[Моржовый оператор в Python / Хабр](https://habr.com/ru/companies/otus/articles/555924/)

Моржовый (walrus) оператор, появившийся в Python 3.8, дает возможность решить сразу две задачи: присвоить значение переменной и вернуть это значение, поэтому порой можно написать код короче и сделать его более читаемым, и он может быть даже более эффективным с точки зрения вычислений.

Давайте посмотрим на моржовый оператор и приведем примеры того, где он может быть полезен.

#### Простой оператор присваивания

Все мы знаем, как присвоить значение переменной. Делается это с помощью простого оператора присваивания:

```python
num = 15
```

И если мы хотим вывести значение этой переменной с помощью функции `print`, то передать переменную `num` мы можем следующим образом:

```python
print(num)# 15
```

### Моржовый оператор

Добавленный в Python 3.8 моржовый оператор (:=), формально известен как оператор присваивания выражения. Он дает возможность присвоить переменные в выражении, включая переменные, которых еще не существует. Как было сказано выше, с помощью простого оператора присваивания (=) мы назначили _num_ равным 15 в контексте отдельного оператора.

> Выражение вычисляется как значение. А инструкция выполняет какое-то действие.

Другими словами, моржовый оператор позволяет нам как присваивать значение переменной, так и возвращать это значение в одном и том же выражении. А называется он так, потому что символ (:=) похож на глаза и бивни моржа, лежащего на боку.

```python
name := Expr
```

`Expr` вычисляется, а затем присваивается имени переменной. Это значение и будет возвращено. Давайте рассмотрим некоторые примеры использования этого оператора.

#### Простой пример

Лучший способ понять, как работает моржовый оператор – этот простой пример. Как и выше, мы хотим присвоить 15 переменной `num`, а затем вывести значение `num`. Мы можем выполнить обе эти задачи в одной строке кода, используя новый оператор следующим образом:

```python
print(num := 15)# 15
```

Значение 15 присваивается `num`. Затем возвращается то же значение, которое становится аргументом для функции `print`_._ Таким образом, выводится 15.

Если мы попытаемся сделать то же самое с помощью обычного оператора присваивания, то получим ошибку типа, поскольку `num = 15` ничего не возвращает.

```python
print(num = 15)# TypeError
```

#### Другой пример

Допустим, мы хотим продолжить запрашивать какие-то данные у пользователя. Если пользователь ничего не вводит, мы можем перестать запрашивать дополнительный ввод. Сделать это с помощью цикла `while` можно следующим образом:

![[Pasted image 20250422130825.png]]

Мы просим пользователя ввести что-нибудь и присваиваем вводу значение. Затем создаем цикл `while`, который выполняется до тех пор, пока введенное значение не пустая строка. Мы выводим «Nice!», если пользователь успешно ввел что-то. Зачем мы запрашиваем у пользователя следующий ввод, присваиваем ему значение и перезапускаем процесс.

Давайте попробуем сделать это с помощью моржового оператора:
![[Pasted image 20250422130850.png]]


Мы запрашиваем у пользователя входные данные и присваиваем их с помощью моржового оператора. Значение это позже возвращается и сравнивается с пустой строкой. Если в результате сравнения приходит `True` (то есть не равно пустой строке), код в цикле `while` выполняется и выводится «Nice!». Если приходит `False`, то дальнейший код не выполняется.

#### Пример со списочным выражением

Еще одним примером того, как можно улучшить читаемость кода и его вычислительную эффективность, служит списочное выражение, которое фильтрует значения.

Допустим, у нас есть список чисел `num_list`, и мы хотим добавить в список куб числа только в случае, если это значение меньше 20. Сделать это можно следующим образом:

![[Pasted image 20250422130905.png]]

Обратите внимание, что нам нужно вызывать функцию `cube` дважды.

Моржовый оператор позволит нам вызвать функцию `cube` всего один раз в нашем списочном выражении, как показано ниже:

![[Pasted image 20250422130918.png]]


Значение `cube(x)` присваивается `y`, затем возвращается и сравнивается с 20. Значение `y` будет добавлено в список только в том случае, если оно меньше 20. Обратите внимание, что функция `cube()` вызывается только один раз, что повышает эффективность кода. И повышение эффективности тем существеннее, чем более сложна для вычисления функция.
